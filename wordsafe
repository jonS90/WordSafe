#!/usr/bin/env ruby
#The previous comment allows unix to automatically identify this as a ruby script

# (c) Jon Smithers 2014


require 'pathname'
require 'tempfile'
require 'io/console'
require 'parseconfig'
require 'openssl'
require 'fileutils'

class WordSafe
	PROGRAM_NAME = "WordSafe" 
	KEYLENGTH = 128 
	# CONFIG_FILE="./config"
	CONFIG_FILE="#{Dir.home}/.wordsafe/config" #TODO ru specific?
	VERSION="0.5"
	@config = ""
	@cipher = OpenSSL::Cipher::AES.new(KEYLENGTH, :CBC)
	@key = ""
	@editor = ""
	@backup_dir = ''
	@shelf_dir = ''
	@do_backup = false
	@accept_fullpath = false
	@append_date = false
	# key = OpenSSL::PKCS5::pbkdf2_hmac(password, "salt", 5, KEYLENGTH, (OpenSSL::Digest::SHA1.new))

	def initialize
		config_init()
		@backup_dir = "#{File.expand_path('~')}/.wordsafe/"
		@shelf_dir =  "#{File.expand_path('~')}/.wordsafe/"
	end

	def set_key(password)
		@key = OpenSSL::PKCS5::pbkdf2_hmac(password, "salt", 5, KEYLENGTH, (OpenSSL::Digest::SHA1.new))
	end

	def key!()
		if (@key == "")
			raise RuntimeError, "key not set"
		end
	end

	def encrypt(plaintext) 
		key!
		cipher = OpenSSL::Cipher.new("AES-#{KEYLENGTH}-CBC")
		cipher.encrypt
		cipher.key = @key
		cipher.update(plaintext) + cipher.final
	end

	def decrypt(ciphertext)
		key!
		decipher = OpenSSL::Cipher.new("AES-#{KEYLENGTH}-CBC")
		decipher.decrypt
		decipher.key = @key
		decipher.update(ciphertext) + decipher.final
	end



	# Prints sort of a title or splash screen to the terminal
	def print_title
		puts
		puts "\`7MMF'     A     \`7MF'                  \`7MM   .M\"\"\"bgd            .d' \"\"      "
		puts "  \`MA     ,MA     ,V                      MM  ,MI    \"Y            dM\`         "
		puts "   VM:   ,VVM:   ,V ,pW\"Wq.\`7Mb,od8  ,M\"\"bMM  \`MMb.      ,6\"Yb.   mMMmm.gP\"Ya  "
		puts "    MM.  M' MM.  M'6W'   \`Wb MM' \"',AP    MM    \`YMMNq. 8)   MM    MM ,M'   Yb "
		puts "    \`MM A'  \`MM A' 8M     M8 MM    8MI    MM  .     \`MM  ,pm9MM    MM 8M\"\"\"\"\"\" "
		puts "     :MM;    :MM;  YA.   ,A9 MM    \`Mb    MM  Mb     dM 8M   MM    MM YM.    , "
		puts "      VF      VF    \`Ybmd9'.JMML.   \`Wbmd\"MML.P\"Ybmmd\"  \`Moo9^Yo..JMML.\`Mbmmd' "
		puts
		puts
	end

	# Prints help
	def print_help
  	puts "WordSafe - version #{VERSION}
  		
  USAGE: wordsafe [switches] [encrypted_journal]
           (to edit encrypted file)
     or: wordsafe [switches]
           (to only configure stuff)
  SWITCHES:
  -h, --help                   Print some help and exit.
  -v, --version                Print version and exit.
      --new <name>             Create a new encrypted journal with a new 
                               password.
  -f, --file                   Specify an encrypted journal by its full 
                               filepath instead of a name.
  -a, --append-date            Append today's date after decrypting a text
                               journal.
  -b, --backup                 Backup old version of journal just before re-
                               encrypting.
  -e, --editor <cmd>           Use specified editor just this once.
  -E, --change-editor <cmd>    Use specified editor from here on out.
  -P, --change-password <name> Change the encryption passphrase for specified 
                               file.
      --title                  Print cool-looking title."
	end

# 	-f, --file     Edit encrypted file (or backup)
#   -b, --backup   Before updating, backup journal to .wordsafe directory with the name "{timestamp}_{filename}.wordsafe"
# 	

	def clear_console()
		system "clear" unless system "cls"
		# http://stackoverflow.com/questions/3170553/how-can-i-clear-the-terminal-in-ruby
		# I think this is cross-platform
	end

	def isMac()
		RUBY_PLATFORM.include? "darwin"
	end
	def isLinux()
		RUBY_PLATFORM.include? "linux"
	end


	def config_init()
		# ensure directory is there
		dir = Pathname.new(CONFIG_FILE).dirname
		Dir.mkdir(dir) unless Dir.exist?(dir)

		# ensure config file is there
		if (!File.file?(CONFIG_FILE))
			puts "Creating new configuration file"
			f = File.open(CONFIG_FILE, "w")
			
			if isLinux
				defaulteditor='xdg-open'
			elsif isMac
				defaulteditor='open'
			else
				defualteditor='open'
				puts "YOUR OS IS NOT SUPPORTED"
			end

			f.write("[general]\neditor=#{defaulteditor}");
			f.close();
		end

		@config = ParseConfig.new(CONFIG_FILE)
	end

	def config_save()
		file = File.open(CONFIG_FILE,'w')
		@config.write(file)
		file.close
	end

	def setup_wizard()
		raise "This is not supported yet"
		puts 'This is the setup wizard'

		user = 'echo $USER'
		tempfile = "temporary_file_asdfhjklasdfhjklasdfhjkl"
		File.open(tempfile, "w") {|f| f.write("Hello human. If you're reading this, your editor should do just fine!")}

		exit_status = false
		while (!exit_status) do
			puts "Please enter the command corresponding to your text-editor of choice."
			puts "Some examples are \"gedit\", \"pyroom\", and \"vim\""
			print "> "
			editor = $stdin.gets.chomp
			clear_console
			puts "I must verify that '#{editor}' will work. When it launches, please do the following:"
			puts "   1. Verify that your editor opened an existing file, NOT A BLANK DOCUMENT."
			puts "   2. Close the program to continue this setup wizard."
			puts "Press enter now"
			gets
			
			puts "#{editor} #{tempfile}"
			exit_status = system "#{editor} #{tempfile}"


			if (exit_status != true)
				puts "bad editor!"
			end
		end 

		@config["general"]["editor"] = editor
	end

	def new_empty_journal(path) 
		key!
		encrypted = File.open(path, "w")
		encrypted.write( encrypt "Welcome to your new journal" )
		encrypted.close
	end

	def get_password()
		print "password: "
		password = STDIN.noecho(&:gets).chomp
		puts "unicorns"
		set_key(password)
	end

	def have_key
		if (@key.nil? || @key.empty?) #nil? seems necessary, even though I have no idea how "" turns into nil. 
			get_password
		end
	end

	def have_editor
		if (defined?(@editor)).nil? || @editor.empty?
			@editor = @config["general"]["editor"]
		end
		if (defined?(@editor)).nil? || @editor.empty?
			puts "Defaulting editor to xdg-open"
			editor = "xdg-open"
		end
	end

	def exist!(pathname)
		if (pathname.directory?)
			raise ArgumentError, "This is a directory: \"#{pathname}\""
		end

		if (!pathname.exist?)
			raise IOError, "File does not exist: \"#{pathname}\""
		end

		if (!pathname.readable?)
			raise IOError, "File cannot be read: \"#{pathname}\""
		end
	end

	def new_journal(path_str)
		get_password

		path = Pathname.new(path_str)
		if (path.directory?)
			path = Pathname.new(path.realpath + "journal")
			
			if (path.exist?)
				raise ArgumentError, ("\"" + path.to_s + "\" already exists")
			end
			
			new_empty_journal path
			puts "journal created at \"#{path.to_s}\""
		else
			if (path.exist?)
				plaintext = File.read(path.realpath)

				newpath = Pathname.new(path.to_s + ".wordsafe")
				if (newpath.exist?)
					raise ArgumentError, ("\"" + newpath.to_s + "\" already exists")
				end
				encrypted = File.open(newpath, "w")
				encrypted.write(encrypt plaintext)
				encrypted.close

				puts "\"" + path.to_s + "\" encrypted to \"" + newpath.to_s
			else
				new_empty_journal path
				puts "journal created at \"#{path.to_s}\""
			end
		end
	end

	def get_timestamp()
		time = Time.new
		timestamp = "#{time.year}%02d%02d%02d%02d%02d" % [time.month, time.day, time.hour, time.min, time.sec]
		return timestamp
	end

	# This assumes that backupdir already exists?
	def backup_journal(path_str)
		if @do_backup
			dir, base = File.split(path_str) 
			FileUtils.cp(path_str, "#{@backup_dir}/#{get_timestamp} #{base}")

			puts "file backed up (at #{@backup_dir}/#{get_timestamp} #{base})"
		end
	end

	def append_date(path_str)
		if @append_date
			f = File.open(path_str, 'a')
			f.write("\n" + get_timestamp + "\n")
			f.close
		end
	end

	def open_journal(path_str)
		have_key
		have_editor

		journal = Pathname.new(path_str)
		exist!(journal)

		decrypted_journal = Tempfile.new('decrypted_journal')
		# clear_console

		decrypted_journal.write(decrypt File.read(journal))
		decrypted_journal.close
		append_date(decrypted_journal.path)

		                puts "#{@editor} #{decrypted_journal.path}"
		exit_status = system "#{@editor} #{decrypted_journal.path}"
		if (exit_status != true)
			puts "Your editor might be invalid."
		end


		puts
		print "press enter to re-encrypt and shred evidence"
		$stdin.gets.chomp
		# clear_console
		
		backup_journal(path_str)

		plaintext = File.read(decrypted_journal)
		journal = File.open(path_str, "w")
		journal.write(encrypt plaintext)
		journal.close()

		if isMac
			`rm -P #{decrypted_journal.path}`
		elsif isLinux
			`shred #{decrypted_journal.path}`
		else
			puts "YOUR OS IS NOT SUPPORTED"
		end

		decrypted_journal.unlink
		puts "file re-encrypted"
	end


	def change_password (path_str)
		have_key
		have_editor

		journal = Pathname.new(path_str)
		exist!(journal)

		plaintext = decrypt File.read(journal)

		get_password

		backup_journal(path_str)
		newF = File.open(journal.to_s, "w")
		newF.write(encrypt plaintext)
		puts "changed password"
	end

	def change_path(file_str)
		if @accept_fullpath
			return "#{file_str}"
		else
			return "#{@shelf_dir}/#{file_str}"
		end
	end

	def readArgs
		if (ARGV.size == 0)
			puts "I have nothing to do"
		end

		while (ARGV.size != 0) do
			arg = ARGV.shift()
		  	case arg
		  	when "-a", "--append-date"
		  		@append_date = true
		  	when "-b", "--backup"
		  		@do_backup = true
		  	when "-f", "--file"
		  		@accept_fullpath = true
			when "-h", "--help"
				print_help
				exit
			when "-v", "--version"
				puts VERSION
				exit
			when "--setup"
				setup_wizard
				exit
			when "--new"
				if (ARGV.size == 0)
					raise ArgumentError, "Must specify a path for #{arg} tag"
				end
				arg = ARGV.shift()
				file = change_path(arg)
				new_journal file
				exit
			when "-e", "--editor"
				if (ARGV.size == 0)
					raise ArgumentError, "Must specify an argument for #{arg} tag"
				end
				@editor = ARGV.shift
			when "-E", "--change-editor"
				if (ARGV.size == 0)
					raise ArgumentError, "Must specify an argument for #{arg} tag"
				end
				@editor = ARGV.shift
				@config["general"]["editor"] = @editor
				config_save
			when "-P", "--change-password"
				if (ARGV.size == 0)
					raise ArgumentError, "Must specify a path for #{arg} tag"
				end
				arg = ARGV.shift
				file = change_path(arg)
				change_password(file)
			when "--open-config"
				puts "xdg-open #{CONFIG_FILE}"
				`xdg-open #{CONFIG_FILE}`
				exit
			when "--title"
				print_title
			else
				if ((arg.each_char.to_a)[0] === "-")
					raise ArgumentError, "Unrecognized flag \"#{arg}\""
				else
					file = change_path(arg)
					open_journal(file)
				end
			end	
		end
	end
end


s = WordSafe.new
# s.print_title
s.readArgs
